--- 
layout: post 
title: "ActiveRecord: Inserting a record Pt. 5"
author: Robin Roestenburg 
tags: rails activerecord mychain 
chain: "Digging into Rails"
published_at: "2012-03-14" 
---

This is the fifth and last post in a series where I am figuring out how a record
is inserted into the database by ActiveRecord. Let me recap what I have already
seen in the previous four posts:

* In [part 1](/2012/03/02/activerecord-inserting-a-record-pt-1) I started with
  an example that saved a record into the database and see which methods are
  involved initially.
* [Part 2](/2012/03/05/activerecord-inserting-a-record-pt-2) took a closer look
  at retrieving and typecasting the values that are going to be inserted into
  the database.
* Both [Part 3](/2012/03/08/activerecord-inserting-a-record-pt-3) and [Part
  4](/2012/03/13/activerecord-inserting-a-record-pt-4) discussed the
  `Relation#insert` method which creates the Arel objects that are needed to
  build the SQL statement.

This post will be the last and I will look at the `insert`-method, present on
the connection class. 

### 'The Final Insert'

It is the `ConnectionAdapters::Abstract::DatabaseStatements#insert` method that
gets called from the `Relation#insert`. After all the complex methods I have
come across, it is a relief to see that this is a fairly simple method:

~~~ ruby,showlines
def insert(arel, name = nil, pk = nil, id_value = nil, sequence_name = nil, binds = []) 
  sql, binds = sql_for_insert(to_sql(arel, binds), pk, id_value, sequence_name, binds)
  value      = exec_insert(sql, name, binds)
  id_value || last_inserted_id(value)
end
~~~

The `sql_for_insert` takes the sql generated by Arel (check the result of this
at the end of the [previous
post](/2012/03/13/activerecord-inserting-a-record-pt-4)) and returns it along
with the values for the bind parameters. 

#### Retrieving generated id values 
When using PostgreSQL the method is overridden and adds the `RETURNING` clause
to the insert statement.  I had to look this up, because I was not familiair
with this. From the PostgreSQL wiki: *The simplest way is to retrieve the
assigned SERIAL value with RETURNING.* Using the example, the sql that is
returned looks like this:

~~~ sql
INSERT INTO "monkeys2" ("name") VALUES ($1) RETURNING "id";
~~~
(the original `monkeys` table did not have a primary key, so I have used another
table here - originally named `monkeys2`)

The assigned id of the inserted record is returned as a result of this query.
Ultimately the id is returned from the `monkey.save` call (where these posts
started out).

Now the obvious question is, how does MySQL retrieve the id? I looked it up and
MySQL's adapter class overrides the `insert_sql` class: 

~~~ ruby
def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil)                                                                                                                                 
  super                                                                                                                                                                                                        
  id_value || @connection.last_id                                                                                                                                                                              
end 
~~~

It calls the `super` (listing shown above) and retrieves the generated id from
the connection after the statement has been executed.

#### Executing the statement

The sql statement shown above gets executed by the `exec_insert` method which
delegates to `PostgreSQLAdapter#exec_query` to execute the query. This is a
pretty low-level method and I will not go into too much of the details. 

One thing that is interesting, is that (on Postgres anyway) when bind parameters
are used it will execute the insert/query using a prepared statement (which
obviously helps performance).

### End...  

I guess that's about it for basic insertion of records into the database. **I've
posted the code example for this blog post on Github, check it out
[here](https://github.com/robinroestenburg/digging-into-rails/tree/master/003-connecting-to-the-database).**

I will continue my posts by looking at the selection part which is a lot more
complicated (especially from an Arel point of view). Might need to take a look
at associations in order to be able to generate some more interesting queries. 

