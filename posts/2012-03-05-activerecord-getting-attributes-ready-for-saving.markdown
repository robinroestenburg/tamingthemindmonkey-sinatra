--- 
layout: post 
title: "ActiveRecord: Getting attributes ready for saving"
author: Robin Roestenburg 
tags: rails activerecord arel mychain 
chain: "Digging into Rails"
published_at: "2012-03-05" 
---
**Update 2012-03-06** Rewrote the original post, did not like it. 

A few days back I identified the most important things that happen within Rails
when creating a record in the database, see [this
post](/2012/03/02/activerecord-saving-a-record). Here is what I came up with: 

* create Arel values for each attribute,
* create a Arel *insert-object*,
* insert the record into the database through `ActiveRecord::Relation#insert`,
* transform the Arel object into a database specific SQL string.

Today I will look at the first of these points and see how the Arel value for
each attribute is created. 

Let's look at the source of the `create` method again: 

~~~ ruby,showlinenos
def create
  attributes_values = arel_attributes_values(!id.nil?)

  new_id = self.class.unscoped.insert attributes_values

  self.id ||= new_id if self.class.primary_key

  IdentityMap.add(self) if IdentityMap.enabled?
  @new_record = false
  id
end
~~~

The `attributes_values` in line **#2** get their value from the method
`arel_attributes_values` that is defined in the `ActiveRecord::AttributeMethods`
module. It looks like this: 

~~~ ruby,showlinenos
def arel_attributes_values(include_primary_key = true, include_readonly_attributes = true, attribute_names = @attributes.keys)
  attrs      = {}
  klass      = self.class
  arel_table = klass.arel_table

  attribute_names.each do |name|
    if (column = column_for_attribute(name)) && (include_primary_key || !column.primary)
    
      if include_readonly_attributes || !self.class.readonly_attributes.include?(name)
    
        value = if klass.serialized_attributes.include?(name)
                  @attributes[name].serialized_value
                else
                  read_attribute(name)
                end
    
        attrs[arel_table[name]] = value
      end
    end
  end
  attrs
end
~~~

As you can see, not the greatest code.
  
For each attribute it will retrieve the type casted value for that attribute and 
store it in a hash with the columns Arel-object as a key, see line **#14** in the
above code listing. The type casted value is generated by the method
`ActiveRecord::AttributeMethods#read_attribute`.

### Typecasting attributes

#### Retrieving the column for the attribute
`ActiveRecord::AttributeMethods::Read#read_attribute` first retrieves the column
object for the attribute whose value needs to be type casted using the
`type_cast_attribute` method on the column object (actually a bad name, because
it does not perform any typecasting). 

~~~ ruby
def read_attribute(attr_name)
  # If it's cached, just return it
  @attributes_cache.fetch(attr_name) { |name|
    column = @columns_hash.fetch(name) {
      return self.class.type_cast_attribute(name, @attributes, @attributes_cache)
    }

    value = @attributes.fetch(name) {
      return block_given? ? yield(name) : nil
    }

    if self.class.cache_attribute?(name)
      @attributes_cache[name] = column.type_cast(value)
    else
      column.type_cast value
    end
  }
end
~~~

This method has three cases in which it returns something different:

1. the attribute method is defined in the `generated_external_attribute_methods` 
2. the attributes are not generated yet for this class, define them and run this
   method again (second run should end in step 1)
3. in all other cases, the attribute we are trying to reach is not a persisted
   attribute (as in: it has no database column). The column is return from the
   `attributes` hash.

   The `generated_external_attribute_method` is actually pretty interesting.
   You should know that the attribute methods (like name= and name) are defined
   on the `AttributeMethods` module. The method creates a `Module` and have
   it extend from itself. This way it only has the `AttributeMethod`s methods on
   there and there are available as class method (instead of instance methods)
   which allows Rails to call `method_defined?` which is faster than
   `respond_to?` I guess.

The method returns the `PostgreSQLColumn` object which contains everything we
need to perform the typecasting: the value and access to the database specific
typecasting methods mentioned in the previous post.

#### Typecasting
The `read_attribute` method retrieves the `Column`-object for the given
attribute and uses it to typecast the value of the attribute to a value that 
Arel can use when generating the SQL. In my case, this is performed through the
`PostgreSQLColumn#type_cast` method, which contains the database specific
implementation for Postgres. 

For each data type there is a type cast defined in: 

* The `OID` module which is included in the `PostgreSQLAdapter` class. 
* The `PostgreSQLColumn` module, some generic typecast code from `Column` is
  overwritten here, this should actually be moved to the `OID` module.
* The `Column` module from which `PostgreSQLColumn` inherits. This module
  contains the most generic typecast code.

#### Caching
`ActiveRecord::AttributeMethods::Read#read_attribute` fetches the attributes'
type casted value from the instance variable `@attributes_cache`. If it is not
present, it will generate it first and (depending on if the class is using
caching) it will store it in in the `@attributes_cache` and return it. If the
class is not using caching it will not store the value and just return it.

The method `cache_attributes?` specifies whether or not the attribute value
should be cached. Caching of these type casted values could be useful when
performing the conversion takes a lot of time i.e., when typecasting time
objects. The following types of attributes are cached by default by Rails: 

~~~ ruby
ATTRIBUTE_TYPES_CACHED_BY_DEFAULT = [:datetime, :timestamp, :time, :date]
~~~

You can turn this off by setting `attribute_types_cached_by_default` to an empty
string. Or you could add to it and have more data types be cached. (**Note:** I
have to verify this.)

### Retrieving the Arel attribute object for a column
So, after typecasting the value the `read_attribute` method will return this
value to the `arel_attributes_values` method to be stored in the previously
mentioned hash, see line **#17** in the second code listing of this post.

The `arel_table[attr_name]` call creates a new `Arel::Table` if none exists
yet. The `Arel::Table` has a `[]`-method defined which creates an
`Arel::Attribute` for the parameter (attribute name) that was passed to it.  The
Arel attribute is just a simple struct containing the relation it is being
retrieved from (`Arel::Table` here) and the name of the attribute. 

### Returning the result
All values and Arel attributes are stored inside the `attr` hash which is
returned in line **#21**. This hash will be used to generate the SQL to insert
the record.

More on that in another post.
