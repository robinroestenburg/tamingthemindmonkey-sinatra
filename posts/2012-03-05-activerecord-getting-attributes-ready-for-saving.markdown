--- 
layout: post 
title: "ActiveRecord: Getting attributes ready for saving"
author: Robin Roestenburg 
tags: rails activerecord mychain 
chain: "Digging into Rails"
published_at: "2012-03-05" 
---
A few days back I identified the most important things that happen within Rails
when creating a record in the database, see [this
post](/2012/03/02/activerecord-saving-a-record). Here is what I came up with: 

* create Arel values for each attribute,
* create an Arel *insert-object*,
* insert the record into the database through `ActiveRecord::Relation#insert`,
* transform the Arel object into a database specific SQL string.

Today I will look at the first of these points and see how the Arel values for
each attribute are created. 

### 
The `attributes_values` get their value from the method `arel_attributes_values`
that is defined in the `ActiveRecord::AttributeMethods` module. It looks like
this: 

~~~ ruby,showlinenos
def arel_attributes_values(include_primary_key = true, include_readonly_attributes = true, attribute_names = @attributes.keys)
  attrs      = {}
  klass      = self.class
  arel_table = klass.arel_table

  attribute_names.each do |name|
    if (column = column_for_attribute(name)) && (include_primary_key || !column.primary)
    
      if include_readonly_attributes || !self.class.readonly_attributes.include?(name)
    
        value = if klass.serialized_attributes.include?(name)
                  @attributes[name].serialized_value
                else
                  read_attribute(name)
                end
    
        attrs[arel_table[name]] = value
      end
    end
  end
  attrs
end
~~~

AS you can see, again not the greatest code.
  
For each attribute it will retrieve the typecasted value for that attribute and 
store it in a hash with the columns Arel-object as a key, see line #14 in the
above code listing. The typecasted value is generated by the method
`ActiveRecord::AttributeMethods#read_attribute`.

### Typecasting attributes
The `read_attribute` method retrieves the `Column`-object for the given
attribute and uses it to typecast the value of the attribute to a value that 
Arel can use when generating the SQL. In my case, this is performed through the
`PostgreSQLColumn#type_cast` method, which contains the database specific
implementation for Postgres. 

For each data type there is a type cast defined in: 

* The `OID` module which is included in the `PostgreSQLAdapter` class. 
* The `PostgreSQLColumn` module, some generic typecast code from `Column` is
  overwritten here, this should actually be moved to the `OID` module.
* The `Column` module from which `PostgreSQLColumn` inherits. This module
  contains the most generic typecast code.

So, after typecasting the value the `read_attribute` method will return this
value to the `arel_attributes_values` method to be stored in the previously
mentioned hash.

### Refactoring
At this point I could no longer stand the ugliness of the method
`arel_attributes_values`, so I refactored it. Here is what I came up with: 

~~~ ruby
def arel_attributes_values(pk_attr_allowed = true, readonly_attr_allowed = true, attribute_names = @attributes.keys)
  attrs      = {}
  arel_table = self.class.arel_table

  attribute_names.each do |name|
    if attribute_allowed?(pk_attr_allowed, readonly_attr_allowed, name) 
      attrs[arel_table[name]] = typecasted_attribute_value(name)
    end
  end

  attrs
end

private

def attribute_allowed?(pk_attribute_allowed, readonly_attribute_allowed, name)
  return unless column = column_for_attribute(name)

  (pk_attribute_allowed || !pk_attribute?(column)) && 
    (readonly_attribute_allowed || !readonly_attribute?(name))
end

def readonly_attribute?(name)
  self.class.readonly_attributes.include?(name)
end

def pk_attribute?(column)
  column.primary
end

def typecasted_attribute_value(name)
  if self.class.serialized_attributes.include?(name)
    @attributes[name].serialized_value
  else
    # FIXME: we need @attributes to be used consistently.
    # If the values stored in @attributes were already typecasted, this code 
    # could be simplified
    read_attribute(name)
  end
end
~~~

The main goal of this refactoring was to get rid of the nested ifs and the ugly
if-statement inside the assigment of value. I think I succeeded, I hope
[they](https://github.com/rails/rails/pull/5294) like it :)

### Next
There are still some things left to check in the `read_attribute` code
(refactored or not): 

* Check out the serialized columns, why is there a special case for these
  columns when typecasting?
* Check out to `arel_table` call in the assignment of the key,value-pair to the
  `attr` hash. 

I will continue with this in the next post.
