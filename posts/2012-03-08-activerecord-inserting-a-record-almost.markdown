--- 
layout: post 
title: "ActiveRecord: Inserting a record (almost)"
author: Robin Roestenburg 
tags: rails activerecord mychain 
chain: "Digging into Rails"
published_at: "2012-03-08" 
---
Let's look at the source of the `create` method again: 

~~~ ruby,showlinenos
def create
  attributes_values = arel_attributes_values(!id.nil?)

  new_id = self.class.unscoped.insert attributes_values
  ...
  id
end
~~~

A few days back I identified the most important things that happen within Rails
when creating a record in the database, see [this
post](/2012/03/02/activerecord-saving-a-record). Here is what I came up with: 

* [create Arel values for each
  attribute](/2012/03/05/activerecord-getting-attributes-ready-for-saving) (see
  line **#2**),
* create an Arel *insert-object*,
* transform the Arel object into a database specific SQL string.
* insert the record into the database through `ActiveRecord::Relation#insert`
  (line **#4**),

The second and third are actually performed inside of the `insert`-method. Today
I will look at the second of these points and see how this method works.

The insert method is defined on `ActiveRecord::Relation#insert`. It is a bit
long and not really SRP'ish :-) I will list it anyway, because then I have some
to refer to in the rest post:

~~~ ruby,showlinenos
def insert(values)
  primary_key_value = nil

  if primary_key && Hash === values
    primary_key_value = values[values.keys.find { |k|
      k.name == primary_key
    }]

    if !primary_key_value && connection.prefetch_primary_key?(klass.table_name)
      primary_key_value = connection.next_sequence_value(klass.sequence_name)
      values[klass.arel_table[klass.primary_key]] = primary_key_value
    end
  end

  im = arel.create_insert
  im.into @table

  conn = @klass.connection

  substitutes = values.sort_by { |arel_attr,_| arel_attr.name }
  binds       = substitutes.map do |arel_attr, value|
    [@klass.columns_hash[arel_attr.name], value]
  end

  substitutes.each_with_index do |tuple, i|
    tuple[1] = conn.substitute_at(binds[i][0], i)
  end

  if values.empty? # empty insert
    im.values = Arel.sql(connection.empty_insert_statement_value)
  else
    im.insert substitutes
  end

  conn.insert(
    im,
    'SQL',
    primary_key,
    primary_key_value,
    nil,
    binds)
end
~~~

Basically, the method does the following things:

* Lines #34-#45: Prefetching the primary key value if needed. 
* Lines #55-#56: Create a `Arel::Nodes::InsertStatement` which will be converted
  to sql when actually inserting the record into the database.
* Lines #60-#67: Substitute the actual values by bind parameters (e.g. ? or $1,
  $2, etc. when using Postgres)
* Lines #69-#73: Add the substitued values to the `InsertStatement`-object. 
* Lines #75-#81: Insert the record into the database using the database specific
  connection. 

I will not look at any of the Arel or inserting code. I will discuss these in
separate posts. That leaves me with the first and third bullet points:

##### Lines #34-#45: Prefetching the primary key value if needed
When a primary key is present on the model, this piece of code will try to get
the value for the primary key from the list of values. There are two
possibilities now: 

* A value is found. This means that a value was specified for the primary key
  and that this can be used when inserting the record. No further action is
  needed.
* No value is found. The means that either:
  * The primary key should be automatically generated by the database when
    executing the insert statement. No further action is needed.
  * The primary key should be prefetched from a sequence. In this case, a value 
    is prefetched from the sequence associated with this class (line **#11**)
    before each insert.
    
    Prefetching is turned off by default by Rails. Overriding it would involve
    creating your own database adapter. 

##### Lines #60-#67: Substituting values by bind parameters
This was the code that was the least clear to me. It actually wasn't that
complex, but that's what you get from throwing everything in a big method I
guess.

* First, all attributes are sorted by name (line **#20**) and stored in variable
`substitutes`. 
* This sorted list of attributes and the list of `Column`-objects (stored in
  `@klass.columns_hash`) are used to create a new 2-dimensional array containing
  the `Column`-object as first index and the attribute value (taken from the
  `Arel::Attribute` struct mentioned
  [here](/2012/03/05/activerecord-getting-attributes-ready-for-saving)). The
  result is stored in the `binds`-variable.
* Now, each of the values in the `substitutes` array is substituted by a
  bind parameter. The bind parameter is database specific. Usually it is `?`,
  but in the case of postgres it is `$1`, `$2`, etc.

We end up with two arrays which will be used when insert the record into the
database: 

* `substitutes` containing the `Arel::Attribute`-object and the bind parameter,
  and
* `binds` containing the `Column`-objects and the values to be binded to the
  bind parameters.

In our example case, these look like this:

~~~ text
# substitutes
[[#<struct Arel::Attributes::Attribute relation=#<Arel::Table:0x007f9a4f2bcac8
      @name="monkeys", 
      @engine=ActiveRecord::Model, 
      @columns=nil, 
      @aliases=[],
      @table_alias=nil, 
      @primary_key=nil>, name="name">, 
  "$1"]]

# binds
[[#<ActiveRecord::ConnectionAdapters::PostgreSQLColumn:0x007f9a4f2c3238
      @oid_type=#<ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID::Identity:0x007f9a4f1b5148>,
      @name="name",   
      @sql_type="character varying(255)", 
      @null=false, 
      @limit=255,
      @precision=nil, 
      @scale=nil, 
      @type=:string, 
      @default=nil, 
      @primary=false,
      @coder=nil>, "George"]]
~~~

That is it for today, tomorrow I will look at the rest of the `insert` method.
