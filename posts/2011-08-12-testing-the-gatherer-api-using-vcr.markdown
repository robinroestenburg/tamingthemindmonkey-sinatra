---
layout: post
title: Testing the Gatherer API using VCR
tags: mychain ruby vcr
author: Robin Roestenburg
published_at: "2011-08-12"
---
Today I've worked on the scraper for the checklist pages generated by the search functionality of Gatherer. I'm using the VCR gem in my tests, because I'm depending on the HTML generated by Gatherer for the scraper. On their [GitHub page](https://github.com/myronmarston/vcr) the project is describe as:
&gt; Record your test suite's HTTP interactions and replay them during future test runs for fast, deterministic, accurate tests.

Whenever your tests fire a HTTP request, the VCR will record that requests and its response into a so-called cassette, which essentially is YAML a file containing the request and the response. Maybe I'll elaborate some more about VCR in a later post. For now, check out [this page](http://relishapp.com/myronmarston/vcr) for more (excellent) documentation of the VCR gem.

The initial setup of VCR is pretty simple. Put the following code in your `test_helper.rb`:
    #!ruby
    require 'vcr'

    VCR.config do |c|
      c.cassette_library_dir = 'test/vcr_cassettes'
      c.stub_with :fakeweb
      c.default_cassette_options = { :record =&gt; :new_episodes }
    end

You tell it where to store the cassettes, which stub to use for faking the HTTP requests and provide it with different options. In this case I've set the record-mode to `new_episodes` - which means that new HTTP requests will be allowed and automatically 'taped'.

Ok, so now for the first test. I'm not using Cucumber for my tests (for now just using plain old Test::Unit), but I like to specify my scenarios in Given/When/Then format.

`Given a checklist page containing cards`
`When the scraper processes the page`
`Then it should return all card identifiers on the page`

The test looks like this:
    #!ruby
    class GathererTest &lt; ActiveSupport::TestCase

      include Gatherer

      setup :initialize_html

      test "should return all cards on the checklist for Mirrodin Besieged" do
        scraper = Gatherer::CheckList.new
        identifiers = scraper.get_card_identifiers(Nokogiri::HTML(@mirrodin_besieged_html))
        assert_equal 155, identifiers.size, "Did not return all card identifiers"
      end

      private

        def initialize_html
          VCR.use_cassette('checklist_pages',
                           :record =&gt; :new_episodes) do
            @mirrodin_besieged_html = open(...snip...)
          end
        end
    end

Some notes about this test:

*   The `initialize_html` method initializes the cassette named 'checklist_pages'. This cassette will contain the different checklist pages on Gatherer I'll be using in my tests.
*   The `initialize_html` method is run before each test case. This way, the loading of the checklist page from the cassette does not clutter the actual test code.
*   I've placed the scraper code in a module called `Gatherer` and created a `CheckList` which will contain the scraper for the checklist page. Following the SLR principle the `Checklist` does not retrieve the html of the checklist page, I'll create a class that will interact with the search API of Gatherer later on.
*   The number of 155 cards is the number of cards present in the Mirrodin Besieged set.

Now that I've got a failing test, I can write the implementation of the `get_card_identifiers` method.

I've inspected the Gatherer checklist and card details (see post of yesterday) page. It contains a table of all cards that match the search criteria. A row in the table looks like this (after formatting):
    #!html
    &lt;tr class="cardItem"&gt;&lt;td class="number"&gt;&lt;/td&gt;
      &lt;td class="name"&gt;
        &lt;a
          class="nameLink"
          href="../Card/Details.aspx?multiverseid=1427"
          onclick="return CardLinkAction(event, this, 'SameWindow');"&gt;
            Abomination
        &lt;/a&gt;
      &lt;/td&gt;
      &lt;td class="artist"&gt;Mark Tedin&lt;/td&gt;&lt;td class="color"&gt;Black&lt;/td&gt;
      &lt;td class="rarity"&gt;U&lt;/td&gt;
      &lt;td class="set"&gt;Legends&lt;/td&gt;
    &lt;/tr&gt;

The card details page is called using a unique identifier of the card. As you can see, the identifier can be retrieved from the link in a row on the checklist page (this also explains, why I'm using `get_card_identifiers` instead of for example `get_cards`). The actual `CheckList` class and `get_card_identifiers` I wrote look like this:
    #!ruby
    class CheckList

      # Processes a checklist page and returns an array of card
      # identifiers.
      def get_card_identifiers(page)

        identifiers = []

        page.css(CSS_CARD_ROW).each do |row|
          identifier = get_card_identifier(row)
          identifiers &lt;&lt; identifier
        end

        identifiers
      end

      private

        CSS_CARD_ROW = 'tr.cardItem'
        CSS_LINK_TO_CARD = 'td.name a'

        # Processes a row on a checklist page of a set and returns the
        # card identifier represented by that row.
        def get_card_identifier(row)
          card_link = row.at_css CSS_LINK_TO_CARD
          card_link['href'].slice(/\d+/)
        end
      end

The `get_card_identifiers` code runs a block for each row in the table (row determined by Nokogiri - I'll get back to that in a later post). The link is then again retrieved using Nokogiri, the digits *sliced* from the `href` attribute of the link.

*Day #4 - Argh, glad to get this post done. Posterous and code examples are not very good friends ;)*
