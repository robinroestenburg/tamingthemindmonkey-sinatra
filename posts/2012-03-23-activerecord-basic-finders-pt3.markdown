--- 
layout: post 
title: "ActiveRecord: Basic finders Pt. 3"
author: Robin Roestenburg 
tags: activerecord rails
chain: "Digging into Rails"
published_at: "2012-03-23" 
---

Today we will be examining the last part (hopefully) of the basic finders
series: executing the select statement against the database and filling the
object(s) with the returned result. 

[Last post](/2012/03/20/activerecord-basic-finders-pt2) we ended up in the
`to_a` method which called the `Relation#exec_queries` method. The
`Relation#exec_queries` method will call the `Querying#find_by_sql` method in
case no associations have to be loaded. We will look at association in later
posts, so we will not discuss the path with associations here. 

### Finding
The `find_by_sql` method takes two parameters: 

* the sql to be executed (as determined by Arel)
* the (optional) bind values

~~~ ruby,showlines
def find_by_sql(sql, binds = [])
  logging_query_plan do
    result_set = connection.select_all(sanitize_sql(sql), "#{name} Load", binds)
    column_types = {}

    if result_set.respond_to? :column_types
      column_types = result_set.column_types
    else
      ActiveSupport::Deprecation.warn "the object returned from `select_all` must respond to `column_types`"
    end

    result_set.map { |record| instantiate(record, column_types) }
  end
end
~~~

##### Sanitization
Before passing the sql to the database connection the sql is sanitized by the
`Sanitization#sanitize_sql` method, this will take an array, hash or string of
SQL conditions and convert them into a valid SQL fragment for a WHERE clause.
Some specific *sanitizations* that are performend: 

* replace the `?`-placeholders by the values provided, 
* convert nil-values into NULL,
* convert an Array of values into a IN-clause,
* sanitize single-quotes,

Here are some examples (using send to access the protected method `sanitize_sql`
directly):

~~~ ruby
# Convert sql as generated by Arel into an executable SQL statement.
Tree.send(:sanitize_sql, ["SELECT * FROM trees WHERE species = ?", 'Red Pine']
#=> SELECT * FROM trees WHERE species = 'Red Pine'

# Sanitize single and double quotes in values
Tree.send(:sanitize_sql, ["SELECT * FROM trees WHERE species = ?", 'Red"Pine']
#=> "SELECT * FROM trees WHERE species = 'Red\"Pine'"
Tree.send(:sanitize_sql, ["SELECT * FROM trees WHERE species = ?", "Red'Pine"]
#=> "SELECT * FROM trees WHERE species = 'Red''Pine'"

# Convert array of values to IN-clause
Tree.send(:sanitize_sql, { :species => ['Red Pine', 'Cucumbertree'] })
#=> "\"trees\".\"species\" IN ('Red Pine', 'Cucumbertree')"

# Convert nil-value to NULL
Tree.send(:sanitize_sql, { :species => nil })
#=> "\"trees\".\"species\" IS NULL
~~~

The `sanitize_sql` is an alias for the `sanitize_sql_for_conditions` method that
performs the sanitization together with some other sql sanitizing methods, they
are all located in the `Sanitization` module.

It turns out that the `sanitize_sql` method is not doing anything when it is
called from the `exec_queries` => `find_by_sql` method chain. The supplied `sql` 
parameter (see line **#3**) is actually an Arel object. The values in this
object have already been sanitized when applying the finder options to the
different scopes. For example:

~~~ ruby 
Tree.find(:all, :conditions => ['species = ?', "Red'Pine"])

# Arel object being supplied to the find_by_sql_method
<Arel::SelectManager:0x007fa206116110
  ...
  @wheres=[#<Arel::Nodes::Grouping:0x007fa206115bc0 @expr="species = 'Red''Pine'">], @groups=[], @having=nil>], 
  ... >
~~~

Notice the escaping of the single quotes in the 'Red Pine' value, as seen before
when calling `sanitize_sql` directly.

##### Partial selects
If you supply specific columns in the SELECT instead of the `*`, only those
columns will be fetched: 

~~~ ruby
Tree.find_by_sql ["SELECT * FROM trees WHERE species = ?", 'Red Pine']
#=> [#<Tree id: 2, species: "Red Pine", forest_id: 1>

Tree.find_by_sql ["SELECT species FROM trees WHERE species = ?", 'Red Pine']
# => [#<Tree id: nil, species: "Red Pine">]
~~~

Notice that the association with `Forest` is not shown anymore in the result
(not even as being nil-valued). Let's look at how the instantiation works later,
first take a quick look at how the SQL is being executed.

### Executing the SQL
The `ConnectionAdapters::Abstract::DatabaseStatements.select_all` method (see
line **#3**) delegates to the database specific `select` method, in our case the
PostgreSQL one. 

~~~ ruby
def select(sql, name = nil, binds = [])
  exec_query(sql, name, binds)
end
~~~

We have already seen the `exec_query`-method when discussing [inserting
records](/2012/03/14/activerecord-inserting-a-record-pt-5).

### Instantiating a record from a result
Once the SELECT statement has been executed a object will be instantiated for
each record returned in the result (see line **#12**). I figured this would be
fairly simple, but upon investigating I discovered that the `instantiate`-method
resides in the `Inheritance` module where it does some things in order to be
able to work with STI.

We will look into the instantiation of the retrieved records in the next post.
