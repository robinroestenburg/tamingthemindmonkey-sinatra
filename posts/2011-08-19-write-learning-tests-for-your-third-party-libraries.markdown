---
layout: post
title: "Write learning tests for your third-party libraries"
tags: mychain tdd
author: Robin Roestenburg
published_at: "2011-08-19"
---
A couple of weeks ago I read the book Clean Code (now wishing I've read the book in 2008 when it was first published). In one of the chapters Robert 'Uncle Bob' Martin writes about integrating third-party libraries into your application. Basically he states the following about learning and integrating a library:

-    Learning to use a third-party library is hard.
-    Integrating a third-party library into your existing code-base is hard.
-    Doing both at the same time is twice as hard (and therefore not good practice).

He advocates a different approach: writing **learning tests** for a third-party library. These tests will allow you to explore and understand the behavior of the third-party code in isolation, before integrating it into your production code.

Writing learning tests will even save time (and money):

-    Writing them is free (you have to learn how to work with the library anyway).
-    Changes in behavior of the third-party code on which your application depends will not go unnoticed, because of the presence of these tests. When there are any incompatible changes in the library after an upgrade, the tests will find them.

### Example learning Nokogiri
I don't think I've ever written a test for a third-party library. I'm going to from now on though :) To play around with this concept I've applied this to a library I'm using in my Magic cards application, [Nokogiri](http://nokogiri.org/). I'm using Nokogiri to parse the HTML pages generated by the Gatherer site.

As a first test I want to know how to match a single element in a HTML page. After reading some 'Getting started' documentation on the Nokogiri page, I wrote the following test:

~~~ ruby
test "matching a single element" do
  html = '<table><tbody><tr><td class="foo">bar</td></tr></tbody></table>'
  doc = Nokogiri::HTML(html)
  assert_equal 'bar', ''
end
~~~

This fails of course, because I don't know how match a single HTML-element using Nokogiri. I *do* know I want the test to return the content of the `td` element with the class `foo`, which is `bar`. I had to browse through the documentation to find out how to do this. Finally I got the following passing test:

~~~ ruby
test "matching a single element" do
  html = '<table><tbody><tr><td class="foo">bar</td></tr></tbody></table>'
  doc = Nokogiri::HTML(html)
  assert_equal 'bar', doc.at_css('td.foo').content
end
~~~

Cool, I've learned how to use the library and written a test documenting the behaviour of that library. Now I want to know what happens when no matching element can be found:

~~~ ruby
test "matching a non-existing single element" do
  html = '<table><tbody><tr><td class="bar">foo</td></tr></tbody></table>'
  doc = Nokogiri::HTML(html)
  assert_equal '', doc.at_css('td.foo').content
end
~~~

Again, this fails (could've passed if Nokogiri actually returned an empty string when no element was found):

~~~ text
NoMethodError: undefined method `content' for nil:NilClass
~~~

Now I've learned that when no element is matched Nokogiri returns `nil`. No exception, just `nil`. Here's the passing test:

~~~ ruby
test "matching a non-existing single element" do
  html = '<table><tbody><tr><td class="bar">foo</td></tr></tbody></table>'
  doc = Nokogiri::HTML(html)
  assert_nil doc.at_css('td.foo')
end
~~~

The above examples should illustrate the concept of writing learning tests for your third-party code pretty clear. I've written a couple of more tests for Nokogiri and I think learning the library's behavior using learning tests is far more efficient then depending solely on documentation, examples and trial-and-error while integrating the library into your production code.
